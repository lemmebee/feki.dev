<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>feki.dev</title>
    <link>http://localhost:1313/feki.dev/</link>
    <description>Recent content on feki.dev</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 25 Apr 2025 20:30:56 +0200</lastBuildDate>
    <atom:link href="http://localhost:1313/feki.dev/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Mastering GitLab CI/CD: Dynamic Environment Selection with Child Pipelines</title>
      <link>http://localhost:1313/feki.dev/posts/mastering-gitlab-ci-cd-dynamic-environment-selection-with-child-pipelines/</link>
      <pubDate>Fri, 25 Apr 2025 20:30:56 +0200</pubDate>
      <guid>http://localhost:1313/feki.dev/posts/mastering-gitlab-ci-cd-dynamic-environment-selection-with-child-pipelines/</guid>
      <description>&lt;h2 id=&#34;table-of-contents&#34;&gt;Table of Contents&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#the-problem&#34;&gt;The Problem&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#the-key-challenge&#34;&gt;The Key Challenge&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#failed-approaches&#34;&gt;Failed Approaches&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#the-solution-child-pipelines&#34;&gt;The Solution: Child Pipelines&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#how-the-solution-works&#34;&gt;How the Solution Works&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#key-advantages&#34;&gt;Key Advantages&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#gotchas-and-lessons-learned&#34;&gt;Gotchas and Lessons Learned&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;In modern software development, CI/CD pipelines are crucial for automating testing and deployment processes. However, when your testing strategy involves multiple environments and complex scheduling, pipeline configuration can become challenging. In this article, I&amp;rsquo;ll share how I solved a particularly tricky GitLab CI/CD problem involving environment-specific variables and dynamic environment selection.&lt;/p&gt;</description>
    </item>
    <item>
      <title>About</title>
      <link>http://localhost:1313/feki.dev/about/</link>
      <pubDate>Wed, 16 Apr 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/feki.dev/about/</guid>
      <description></description>
    </item>
    <item>
      <title>From Rigid to Robust: Revamping Our CI Templates for a Modern Workflow</title>
      <link>http://localhost:1313/feki.dev/posts/from-rigid-to-robust-revamping-our-ci-templates-for-a-modern-workflow/</link>
      <pubDate>Thu, 03 Apr 2025 22:30:56 +0200</pubDate>
      <guid>http://localhost:1313/feki.dev/posts/from-rigid-to-robust-revamping-our-ci-templates-for-a-modern-workflow/</guid>
      <description>&lt;p&gt;&lt;strong&gt;tl;dr:&lt;/strong&gt; Our old CI/CD templates were repetitive, inflexible, and hard to maintain. We rebuilt them using a modular, language-agnostic approach with reusable components, smart conditional logic, and automated tooling (like versioning and security scanning). This resulted in faster, more consistent, secure, and maintainable pipelines adaptable to various project needs.&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;table-of-contents&#34;&gt;Table of contents&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#the-challenge-when-templates-become-obstacles&#34;&gt;The Challenge: When Templates Become Obstacles&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#the-transformation-introducing-a-modular-language-agnostic-architecture&#34;&gt;The Transformation: Introducing a Modular, Language-Agnostic Architecture&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#1-modular-design-with-include&#34;&gt;1. Modular Design with &lt;code&gt;include&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#2-language-agnostic-approach--smart-detection&#34;&gt;2. Language-Agnostic Approach &amp;amp; Smart Detection&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#3-unified-pipeline-stages&#34;&gt;3. Unified Pipeline Stages&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#4-advanced-cicd-capabilities&#34;&gt;4. Advanced CI/CD Capabilities&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#the-benefits-a-more-efficient-and-secure-future&#34;&gt;The Benefits: A More Efficient and Secure Future&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Continuous Integration and Continuous Deployment (CI/CD) pipelines are the backbone of modern software development. However, the templates governing these pipelines can often become a source of frustration â€“ rigid, repetitive, difficult to maintain, and struggling to keep up with diverse tech stacks. We faced these exact issues with our internal CI template repository. This is the story of how we transformed our CI architecture from a maintenance headache into a flexible, modular, and powerful asset.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
