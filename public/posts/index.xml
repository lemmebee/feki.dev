<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on feki.dev</title>
    <link>http://localhost:1313/feki.dev/posts/</link>
    <description>Recent content in Posts on feki.dev</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 28 Aug 2025 21:14:07 +0200</lastBuildDate>
    <atom:link href="http://localhost:1313/feki.dev/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Migrating Postgresql Rds From Multiple Aws Accounts to a Single Rds Instance</title>
      <link>http://localhost:1313/feki.dev/posts/migrating-postgresql-rds-from-multiple-aws-accounts-to-a-single-rds-instance/</link>
      <pubDate>Thu, 28 Aug 2025 21:14:07 +0200</pubDate>
      <guid>http://localhost:1313/feki.dev/posts/migrating-postgresql-rds-from-multiple-aws-accounts-to-a-single-rds-instance/</guid>
      <description>&lt;h1 id=&#34;table-of-contents&#34;&gt;Table of Contents&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#the-scenario&#34;&gt;The Scenario&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#our-architecture&#34;&gt;Our Architecture&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#prerequisites&#34;&gt;Prerequisites&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#the-migration-strategy-why-pg_dump-and-pg_restore&#34;&gt;The Migration Strategy: Why &lt;code&gt;pg_dump&lt;/code&gt; and &lt;code&gt;pg_restore&lt;/code&gt;?&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#step-by-step-migration-guide&#34;&gt;Step-by-Step Migration Guide&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#phase-1-preparing-the-target-non-prod-account&#34;&gt;Phase 1: Preparing the Target (Non-Prod) Account&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#phase-2-preparing-the-source-accounts-a--b&#34;&gt;Phase 2: Preparing the Source Accounts (A &amp;amp; B)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#phase-3-executing-the-migration-script&#34;&gt;Phase 3: Executing the Migration Script&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#phase-4-post-migration-validation&#34;&gt;Phase 4: Post-Migration Validation&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#final-considerations&#34;&gt;Final Considerations&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;As organizations grow, it&amp;rsquo;s common for development and testing environments to become siloed in separate AWS accounts. While this is great for security and billing isolation, it can lead to increased management overhead and costs. A common strategy to streamline operations is to consolidate these non-production databases into a single, shared RDS instance in a central &amp;ldquo;Non-Prod&amp;rdquo; account.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Mastering GitLab CI/CD: Dynamic Environment Selection with Child Pipelines</title>
      <link>http://localhost:1313/feki.dev/posts/mastering-gitlab-ci-cd-dynamic-environment-selection-with-child-pipelines/</link>
      <pubDate>Fri, 25 Apr 2025 20:30:56 +0200</pubDate>
      <guid>http://localhost:1313/feki.dev/posts/mastering-gitlab-ci-cd-dynamic-environment-selection-with-child-pipelines/</guid>
      <description>&lt;h2 id=&#34;table-of-contents&#34;&gt;Table of Contents&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#the-problem&#34;&gt;The Problem&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#the-key-challenge&#34;&gt;The Key Challenge&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#failed-approaches&#34;&gt;Failed Approaches&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#the-solution-child-pipelines&#34;&gt;The Solution: Child Pipelines&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#how-the-solution-works&#34;&gt;How the Solution Works&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#key-advantages&#34;&gt;Key Advantages&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#gotchas-and-lessons-learned&#34;&gt;Gotchas and Lessons Learned&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;In modern software development, CI/CD pipelines are crucial for automating testing and deployment processes. However, when your testing strategy involves multiple environments and complex scheduling, pipeline configuration can become challenging. In this article, I&amp;rsquo;ll share how I solved a particularly tricky GitLab CI/CD problem involving environment-specific variables and dynamic environment selection.&lt;/p&gt;</description>
    </item>
    <item>
      <title>From Rigid to Robust: Revamping Our CI Templates for a Modern Workflow</title>
      <link>http://localhost:1313/feki.dev/posts/from-rigid-to-robust-revamping-our-ci-templates-for-a-modern-workflow/</link>
      <pubDate>Thu, 03 Apr 2025 22:30:56 +0200</pubDate>
      <guid>http://localhost:1313/feki.dev/posts/from-rigid-to-robust-revamping-our-ci-templates-for-a-modern-workflow/</guid>
      <description>&lt;p&gt;&lt;strong&gt;tl;dr:&lt;/strong&gt; Our old CI/CD templates were repetitive, inflexible, and hard to maintain. We rebuilt them using a modular, language-agnostic approach with reusable components, smart conditional logic, and automated tooling (like versioning and security scanning). This resulted in faster, more consistent, secure, and maintainable pipelines adaptable to various project needs.&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;table-of-contents&#34;&gt;Table of contents&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#the-challenge-when-templates-become-obstacles&#34;&gt;The Challenge: When Templates Become Obstacles&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#the-transformation-introducing-a-modular-language-agnostic-architecture&#34;&gt;The Transformation: Introducing a Modular, Language-Agnostic Architecture&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#1-modular-design-with-include&#34;&gt;1. Modular Design with &lt;code&gt;include&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#2-language-agnostic-approach--smart-detection&#34;&gt;2. Language-Agnostic Approach &amp;amp; Smart Detection&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#3-unified-pipeline-stages&#34;&gt;3. Unified Pipeline Stages&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#4-advanced-cicd-capabilities&#34;&gt;4. Advanced CI/CD Capabilities&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#the-benefits-a-more-efficient-and-secure-future&#34;&gt;The Benefits: A More Efficient and Secure Future&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Continuous Integration and Continuous Deployment (CI/CD) pipelines are the backbone of modern software development. However, the templates governing these pipelines can often become a source of frustration â€“ rigid, repetitive, difficult to maintain, and struggling to keep up with diverse tech stacks. We faced these exact issues with our internal CI template repository. This is the story of how we transformed our CI architecture from a maintenance headache into a flexible, modular, and powerful asset.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
